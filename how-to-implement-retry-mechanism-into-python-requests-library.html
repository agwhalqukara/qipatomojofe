<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>How to implement retry mechanism into Python Requests library? | PicoBlog</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="I would like to add a retry mechanism to Python Requests library, so scripts that are using it will retry for non-fatal errors.
At this moment I do consider three kind of errors to be recoverable:
 HTTP return codes 502, 503, 504 host not found (less important now) request timeout  At the first stage I do want to retry specified 5xx requests every minute.
I want to be able to add this functionality transparently, without having to manually implement recovery for each HTTP call made from inside these scripts or libraries that are using Python Requests."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>PicoBlog</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>How to implement retry mechanism into Python Requests library?</h1><div><strong>Publish date: </strong>2024-10-01</div><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I would like to add a retry mechanism to Python <a href=# rel=noreferrer>Requests</a> library, so scripts that are using it will retry for non-fatal errors.</p><p>At this moment I do consider three kind of errors to be recoverable:</p><ul><li>HTTP return codes 502, 503, 504</li><li>host not found (less important now)</li><li>request timeout</li></ul><p>At the first stage I do want to retry specified 5xx requests every minute.</p><p>I want to be able to add this functionality transparently, without having to manually implement recovery for each HTTP call made from inside these scripts or libraries that are using Python Requests.</p><span class=d-none itemprop=commentCount>5</span><h2 class=mb0 data-answercount=6>6 Answers</h2><p>This snippet of code will make all HTTP requests from the same session retry for a total of 5 times, sleeping between retries with an increasing backoff of 0s, 2s, 4s, 8s, 16s (the first retry is done immediately). It will retry on basic connectivity issues (including DNS lookup failures), and HTTP status codes of 502, 503 and 504.</p><pre><code>import logging import requests from requests.adapters import HTTPAdapter, Retry logging.basicConfig(level=logging.DEBUG) s = requests.Session() retries = Retry(total=5, backoff_factor=1, status_forcelist=[ 502, 503, 504 ]) s.mount('http://', HTTPAdapter(max_retries=retries)) s.get("http://httpstat.us/503") </code></pre><p>See <a href=# rel=noreferrer>Retry class</a> for details.</p><span class=d-none itemprop=commentCount>11</span><p>This is a snippet of code I used to retry for the petitions made with urllib2. Maybe you could use it for your purposes:</p><pre><code>retries = 1 success = False while not success: try: response = urllib2.urlopen(request) success = True except Exception as e: wait = retries * 30; print 'Error! Waiting %s secs and re-trying...' % wait sys.stdout.flush() time.sleep(wait) retries += 1 </code></pre><p>The waiting time grows incrementally to avoid be banned from server.</p><span class=d-none itemprop=commentCount>2</span><p>Possible solution using <a href=# rel=noreferrer>retrying package</a></p><pre><code>from retrying import retry import requests def retry_if_connection_error(exception): """ Specify an exception you need. or just True""" #return True return isinstance(exception, ConnectionError) # if exception retry with 2 second wait @retry(retry_on_exception=retry_if_connection_error, wait_fixed=2000) def safe_request(url, **kwargs): return requests.get(url, **kwargs) response = safe_request('test.com') </code></pre><span class=d-none itemprop=commentCount>3</span><pre><code>from requests.adapters import HTTPAdapter from urllib3.util.retry import Retry MAX_RETRY = 2 MAX_RETRY_FOR_SESSION = 2 BACK_OFF_FACTOR = 0.3 TIME_BETWEEN_RETRIES = 1000 ERROR_CODES = (500, 502, 504) def requests_retry_session(retries=MAX_RETRY_FOR_SESSION, back_off_factor=BACK_OFF_FACTOR, status_force_list=ERROR_CODES, session=None): session = session retry = Retry(total=retries, read=retries, connect=retries, backoff_factor=back_off_factor, status_forcelist=status_force_list, method_whitelist=frozenset(['GET', 'POST'])) adapter = HTTPAdapter(max_retries=retry) session.mount('http://', adapter) session.mount('https://', adapter) return session class ConfigService: def __init__(self): self.session = requests_retry_session(session=requests.Session()) def call_to_api(): config_url = 'http://localhost:8080/predict/' headers = { "Content-Type": "application/json", "x-api-key": self.x_api_key } response = self.session.get(config_url, headers=headers) return response </code></pre><span class=d-none itemprop=commentCount>1</span><p>I was able to obtain the desired level of reliability by extending <code>requests.Session</code> class.</p><p>Here is the code <a href=# rel="nofollow noreferrer">https://bitbucket.org/bspeakmon/jira-python/src/a7fca855394402f58507ca4056de87ccdbd6a213/jira/resilientsession.py?at=master</a></p><p><strong>EDIT</strong> That code was:</p><pre><code>from requests import Session from requests.exceptions import ConnectionError import logging import time class ResilientSession(Session): """ This class is supposed to retry requests that do return temporary errors. At this moment it supports: 502, 503, 504 """ def __recoverable(self, error, url, request, counter=1): if hasattr(error,'status_code'): if error.status_code in [502, 503, 504]: error = "HTTP %s" % error.status_code else: return False DELAY = 10 * counter logging.warn("Got recoverable error [%s] from %s %s, retry #%s in %ss" % (error, request, url, counter, DELAY)) time.sleep(DELAY) return True def get(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).get(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'GET', counter): continue return r def post(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).post(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'POST', counter): continue return r def delete(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).delete(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'DELETE', counter): continue return r def put(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).put(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PUT', counter): continue return r def head(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).head(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'HEAD', counter): continue return r def patch(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).patch(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PATCH', counter): continue return r def options(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).options(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'OPTIONS', counter): continue return r </code></pre><span class=d-none itemprop=commentCount>4</span><p><strong>Method to retry certain logic if some exception has occured at time intervals t1=1 sec, t2=2 sec, t3=4 sec.</strong> We can increase/decrease the time interval as well.</p><pre><code>MAX_RETRY = 3 retries = 0 try: call_to_api() // some business logic goes here. except Exception as exception: retries += 1 if retries &lt;= MAX_RETRY: print("ERROR=Method failed. Retrying ... #%s", retries) time.sleep((1 &lt;&lt; retries) * 1) // retry happens after time as a exponent of 2 continue else: raise Exception(exception) </code></pre><span class=d-none itemprop=commentCount></span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoaWxqZmyBcYWOoaawZaSkeqq5z6Wcpp2eqXqzsdOrsGallZi1orrIrKRmoZ6pvG682K2fqKZdp7KywcSsq6xlnJ6vs63Rsg%3D%3D</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. Â© 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>